#!/system/bin/sh

PKG_NAME="com.tencent.mf.uam"
LIST_FILE="/sdcard/found_files.txt"
BACKUP_DIR="/sdcard/backup_${PKG_NAME}_$(date +%Y%m%d_%H%M%S)"
CUSTOM_UIDS=""
SPECIAL_PATTERNS="HANYCJ"

# 颜色定义
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
PURPLE='\033[1;35m'
CYAN='\033[1;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# 检查root权限
if [ "$(id -u)" -ne 0 ]; then
    echo -e "${RED}错误：需要root权限运行此脚本${NC}"
    echo -e "${YELLOW}请先执行: su${NC}"
    exit 1
fi

# 动画函数
show_animation() {
    local text="$1"
    echo -ne "${CYAN}"
    for ((i=0; i<${#text}; i++)); do
        echo -n "${text:$i:1}"
        sleep 0.03
    done
    echo -e "${NC}"
}

show_progress() {
    local duration=$1
    local chars="/-\|"
    local i=0
    while [ $duration -gt 0 ]; do
        printf "\r${CYAN}处理中... ${chars:$((i % 4)):1} ${NC}"
        sleep 0.1
        ((i++))
        ((duration--))
    done
    printf "\r${GREEN}✓ 完成！${NC}%-20s\n" ""
}

# 自动检测SD卡Download目录所有者UID
auto_detect_download_uid() {
    echo -e "${BLUE}正在自动检测SD卡Download目录所有者UID...${NC}"
    
    # 常见的SD卡路径
    SD_PATHS="/storage/emulated/0/Download /sdcard/Download /mnt/sdcard/Download /storage/emulated/0/download /sdcard/download"
    
    local detected_uid=""
    
    for download_path in $SD_PATHS; do
        if [ -d "$download_path" ]; then
            echo -e "${GREEN}发现Download目录: $download_path${NC}"
            
            # 获取目录所有者
            local owner=$(ls -ld "$download_path" 2>/dev/null | awk '{print $3}')
            if [ -n "$owner" ] && [ "$owner" != "root" ]; then
                # 检查是否是数字UID
                if echo "$owner" | grep -qE '^[0-9]+$'; then
                    detected_uid="$owner"
                    echo -e "${GREEN}✓ 检测到UID: $detected_uid (来自: $download_path)${NC}"
                    break
                else
                    # 如果是用户名，尝试转换为UID
                    local uid_from_name=$(id -u "$owner" 2>/dev/null)
                    if [ -n "$uid_from_name" ]; then
                        detected_uid="$uid_from_name"
                        echo -e "${GREEN}✓ 检测到UID: $detected_uid (用户: $owner)${NC}"
                        break
                    fi
                fi
            fi
            
            # 检查目录下的文件所有者
            local first_file=$(find "$download_path" -maxdepth 1 -type f 2>/dev/null | head -1)
            if [ -n "$first_file" ]; then
                local file_owner=$(ls -ld "$first_file" 2>/dev/null | awk '{print $3}')
                if [ -n "$file_owner" ] && [ "$file_owner" != "root" ]; then
                    if echo "$file_owner" | grep -qE '^[0-9]+$'; then
                        detected_uid="$file_owner"
                        echo -e "${GREEN}✓ 检测到UID: $detected_uid (来自文件所有者)${NC}"
                        break
                    else
                        local uid_from_name=$(id -u "$file_owner" 2>/dev/null)
                        if [ -n "$uid_from_name" ]; then
                            detected_uid="$uid_from_name"
                            echo -e "${GREEN}✓ 检测到UID: $detected_uid (文件用户: $file_owner)${NC}"
                            break
                        fi
                    fi
                fi
            fi
        fi
    done
    
    # 如果没有找到，检查常见的媒体UID
    if [ -z "$detected_uid" ]; then
        echo -e "${YELLOW}⚠ 未能自动检测到UID，尝试使用常见媒体UID...${NC}"
        # 常见的媒体服务UID
        common_media_uids="10285 1023 1024 1013 9999"
        for media_uid in $common_media_uids; do
            # 检查该UID是否在系统中存在文件
            if find /storage /mnt -user "$media_uid" 2>/dev/null | head -1 | grep -q .; then
                detected_uid="$media_uid"
                echo -e "${GREEN}✓ 使用常见媒体UID: $detected_uid${NC}"
                break
            fi
        done
    fi
    
    if [ -n "$detected_uid" ]; then
        CUSTOM_UIDS="$detected_uid"
        echo -e "${GREEN}🎯 已自动设置UID: $CUSTOM_UIDS${NC}"
    else
        echo -e "${YELLOW}⚠ 无法自动检测UID，将仅使用应用UID${NC}"
    fi
    
    return 0
}

# 显示标题
clear
echo -e "${PURPLE}"
echo "=================================================="
echo "                                                  "
echo "            🛡️  117清理大师专业版 🛡️             "
echo "                                                  "
echo "=================================================="
echo -e "${NC}"
sleep 1

show_animation "正在初始化系统..."
echo

# 自动检测Download目录UID
auto_detect_download_uid

echo
echo -e "${YELLOW}=== UID设置确认 ===${NC}"
echo -e "${CYAN}当前设置:${NC}"
echo -e "${GREEN}应用UID: 自动检测${NC}"
echo -e "${GREEN}媒体UID: ${CUSTOM_UIDS:-未设置}${NC}"
echo -n -e "${BLUE}是否需要手动输入其他UID？(y/N): ${NC}"
read -r manual_input

if [ "$manual_input" = "y" ] || [ "$manual_input" = "Y" ]; then
    echo -n -e "${GREEN}请输入自定义UID: ${NC}"
    read -r custom_input
    if [ -n "$custom_input" ]; then
        CUSTOM_UIDS="$custom_input"
        echo -e "${GREEN}✓ 已设置自定义UID: $CUSTOM_UIDS${NC}"
    fi
fi

# 1. 获取应用的主要UID
echo
show_animation "正在获取应用UID..."

# 方法1: 从packages.list获取
pkg_uid=$(grep -E "^${PKG_NAME}[[:space:]]" /data/system/packages.list 2>/dev/null | awk '{print $2}')

# 方法2: 从packages.xml获取（备用）
if [ -z "$pkg_uid" ]; then
    pkg_uid=$(grep -A5 -B5 "name=\"$PKG_NAME\"" /data/system/packages.xml 2>/dev/null | grep -o 'userId="[0-9]*"' | head -1 | cut -d'"' -f2)
    [ -n "$pkg_uid" ] && echo -e "${GREEN}✓ 从packages.xml找到UID: $pkg_uid${NC}"
fi

# 方法3: 从目录所有者获取
if [ -z "$pkg_uid" ]; then
    for user_dir in /data/data/$PKG_NAME /data/user/*/$PKG_NAME; do
        if [ -d "$user_dir" ]; then
            pkg_uid=$(ls -ld "$user_dir" 2>/dev/null | awk '{print $3}')
            [ -n "$pkg_uid" ] && echo -e "${GREEN}✓ 从目录所有者找到UID: $pkg_uid${NC}" && break
        fi
    done
fi

# 方法4: 从进程信息获取
if [ -z "$pkg_uid" ]; then
    pkg_uid=$(ps -o PID,USER -A 2>/dev/null | grep -i "$PKG_NAME" | head -1 | awk '{print $2}')
    [ -n "$pkg_uid" ] && echo -e "${GREEN}✓ 从进程信息找到UID: $pkg_uid${NC}"
fi

# 如果还是找不到UID，继续执行但不使用UID搜索
if [ -z "$pkg_uid" ]; then
    echo -e "${YELLOW}⚠ 无法确定应用UID，将仅使用路径匹配搜索${NC}"
    all_uids="$CUSTOM_UIDS"
else
    all_uids="$pkg_uid $CUSTOM_UIDS"
    echo -e "${GREEN}✓ 应用UID: $pkg_uid${NC}"
fi

echo -e "${BLUE}将搜索以下UID: $all_uids${NC}"

# 2. 自动识别DataBackup目录
echo
show_animation "正在识别排除目录..."

EXCLUDE_DIRS=""
STORAGE_PATHS="/storage/emulated /sdcard /mnt/sdcard /mnt/androidwritable /mnt/installer /mnt/pass_through /mnt/user"

for base_path in $STORAGE_PATHS; do
    if [ -d "$base_path" ]; then
        for user_dir in "$base_path"/*; do
            if [ -d "$user_dir" ]; then
                if [ -d "$user_dir/Download/DataBackup" ]; then
                    EXCLUDE_DIRS="$EXCLUDE_DIRS $user_dir/Download/DataBackup"
                    echo -e "${GREEN}✓ 发现排除目录: $user_dir/Download/DataBackup${NC}"
                fi
                if [ -d "$user_dir/download/DataBackup" ]; then
                    EXCLUDE_DIRS="$EXCLUDE_DIRS $user_dir/download/DataBackup"
                    echo -e "${GREEN}✓ 发现排除目录: $user_dir/download/DataBackup${NC}"
                fi
                if [ -d "$user_dir/DataBackup" ]; then
                    EXCLUDE_DIRS="$EXCLUDE_DIRS $user_dir/DataBackup"
                    echo -e "${GREEN}✓ 发现排除目录: $user_dir/DataBackup${NC}"
                fi
            fi
        done
    fi
done

if [ -z "$EXCLUDE_DIRS" ]; then
    echo -e "${YELLOW}⚠ 未发现DataBackup目录，使用默认排除设置${NC}"
    EXCLUDE_DIRS="/storage/emulated/0/Download/DataBackup /sdcard/Download/DataBackup"
else
    echo -e "${GREEN}✓ 已自动识别并排除以下目录${NC}"
    echo "$EXCLUDE_DIRS"
fi

# 3. 清空之前的列表文件
> "$LIST_FILE"

# 构建排除正则表达式（修复空表达式问题）
if [ -n "$EXCLUDE_DIRS" ]; then
    EXCLUDE_DIRS_CLEAN=$(echo "$EXCLUDE_DIRS" | sed 's/^ *//;s/ *$//' | sed 's/  */ /g')
    if [ -n "$EXCLUDE_DIRS_CLEAN" ]; then
        EXCLUDE_DIRS_REGEX=$(echo "$EXCLUDE_DIRS_CLEAN" | sed 's/ /|/g' | sed 's/\//\\\//g')
    else
        EXCLUDE_DIRS_REGEX="^$"
    fi
else
    EXCLUDE_DIRS_REGEX="^$"
fi

EXCLUDE_APPS_REGEX="qq|QQ|wechat|WeChat|wx|WX|tim|TIM|qzone|QZone"

echo
show_animation "开始深度扫描系统..."
echo

# 构建find排除参数
build_exclude_prune() {
    for exclude_dir in $EXCLUDE_DIRS; do
        if [ -d "$exclude_dir" ]; then
            echo "-path \"$exclude_dir*\" -prune -o"
        fi
    done
}

# 1. 包名路径搜索
echo -e "${BLUE}[1/5] 包名路径搜索...${NC}"
{
    build_exclude_prune
    echo "-path \"*${PKG_NAME}*\" -print"
} | xargs find /data 2>/dev/null >> "$LIST_FILE"

{
    build_exclude_prune  
    echo "-path \"*${PKG_NAME}*\" -print"
} | xargs find /storage /mnt 2>/dev/null 2>/dev/null >> "$LIST_FILE"
show_progress 10

# 2. 关键词搜索
echo -e "${BLUE}[2/5] 关键词搜索...${NC}"
if [ -n "$EXCLUDE_DIRS_REGEX" ] && [ "$EXCLUDE_DIRS_REGEX" != "^$" ]; then
    find /data -name "*mf.uam*" 2>/dev/null | \
    grep -vE "$EXCLUDE_APPS_REGEX" | \
    grep -vE "$EXCLUDE_DIRS_REGEX" >> "$LIST_FILE"
    
    find /storage /mnt \( -name "*mf.uam*" \) 2>/dev/null 2>/dev/null | \
    grep -vE "$EXCLUDE_APPS_REGEX" | \
    grep -vE "$EXCLUDE_DIRS_REGEX" >> "$LIST_FILE"
fi
show_progress 10

# 3. 特殊模式搜索
echo -e "${BLUE}[3/5] 特殊模式搜索...${NC}"
for pattern in $SPECIAL_PATTERNS; do
    if [ -n "$EXCLUDE_DIRS_REGEX" ] && [ "$EXCLUDE_DIRS_REGEX" != "^$" ]; then
        find /data -name "${pattern}*" 2>/dev/null | grep -vE "$EXCLUDE_DIRS_REGEX" >> "$LIST_FILE"
        find /storage /mnt -name "${pattern*}" 2>/dev/null 2>/dev/null | grep -vE "$EXCLUDE_DIRS_REGEX" >> "$LIST_FILE"
    else
        find /data -name "${pattern}*" 2>/dev/null >> "$LIST_FILE"
        find /storage /mnt -name "${pattern}*" 2>/dev/null 2>/dev/null >> "$LIST_FILE"
    fi
done
show_progress 10

# 4. UID搜索
echo -e "${BLUE}[4/5] UID搜索...${NC}"
for uid in $all_uids; do
    {
        build_exclude_prune
        echo "-user \"$uid\" -print"  
    } | xargs find /data 2>/dev/null | \
    grep -vE "$EXCLUDE_APPS_REGEX" | \
    while read file; do
        file_lower=$(echo "$file" | tr '[:upper:]' '[:lower:]')
        if echo "$file_lower" | grep -q "uam"; then
            owner=$(ls -ld "$file" 2>/dev/null | awk '{print $3}' 2>/dev/null)
            echo "[UID:$owner] $file"
        fi
    done >> "$LIST_FILE"
done
show_progress 10

# 5. 文件内容扫描
echo -e "${BLUE}[5/5] 文件内容扫描...${NC}"
find /data -type f -size -1M 2>/dev/null | head -500 | while read file; do
    if [ -n "$EXCLUDE_DIRS_REGEX" ] && [ "$EXCLUDE_DIRS_REGEX" != "^$" ]; then
        if echo "$file" | grep -qE "$EXCLUDE_DIRS_REGEX"; then
            continue
        fi
    fi
    if file "$file" 2>/dev/null | grep -q -E "(text|XML|JSON|HTML)"; then
        if grep -q -i -E "(tencent\.mf\.uam|mf\.uam|HANYCJ)" "$file" 2>/dev/null; then
            if ! echo "$file" | grep -qE "$EXCLUDE_APPS_REGEX"; then
                echo "[CONTENT] $file" >> "${LIST_FILE}.content"
            fi
        fi
    fi
done

if [ -f "${LIST_FILE}.content" ]; then
    cat "${LIST_FILE}.content" >> "$LIST_FILE"
    rm -f "${LIST_FILE}.content"
fi
show_progress 10

# 去重和分类
echo -e "${BLUE}处理扫描结果...${NC}"
sort -u "$LIST_FILE" > "${LIST_FILE}.tmp"
mv "${LIST_FILE}.tmp" "$LIST_FILE"

# 结果显示
echo
echo -e "${PURPLE}=== 扫描结果 ===${NC}"
file_count=$(wc -l < "$LIST_FILE" 2>/dev/null || echo 0)

if [ "$file_count" -eq 0 ]; then
    echo -e "${GREEN}✓ 未找到相关文件。${NC}"
    exit 0
fi

echo -e "${GREEN}✓ 找到 $file_count 个相关文件${NC}"
echo -e "${CYAN}文件预览:${NC}"
head -10 "$LIST_FILE" | awk '{print NR ". " $0}'

# 主菜单
while true; do
    echo
    echo -e "${PURPLE}==================================================${NC}"
    echo -e "${WHITE}                  🎮 主菜单 🎮${NC}"
    echo -e "${PURPLE}==================================================${NC}"
    echo -e "${CYAN}1. 📋 显示完整文件列表${NC}"
    echo -e "${CYAN}2. 🗑️  删除扫描到的文件${NC}"
    echo -e "${YELLOW}3. 🎯 专项清理（游戏缓存清理）${NC}"
    echo -e "${RED}4. 🚫 网络屏蔽（去人脸功能）${NC}"
    echo -e "${GREEN}5. ✅ 退出脚本${NC}"
    echo -e "${PURPLE}==================================================${NC}"
    echo -n -e "${BLUE}请选择操作 (1-5): ${NC}"
    read -r choice

    case "$choice" in
        1) 
            echo -e "${CYAN}完整文件列表：${NC}"
            cat "$LIST_FILE"
            ;;
        2)
            echo -n -e "${RED}确认删除 $file_count 个文件？(输入 DELETE 确认): ${NC}"
            read -r confirm
            
            if [ "$confirm" = "DELETE" ]; then
                echo -e "${YELLOW}开始删除...${NC}"
                deleted=0
                error_count=0
                
                while IFS= read -r file; do
                    file_clean=$(echo "$file" | sed 's/\[UID:[^]]*\] //; s/\[CONTENT\] //')
                    
                    if [ -e "$file_clean" ] || [ -L "$file_clean" ]; then
                        if [ -d "$file_clean" ]; then
                            if rm -rf "$file_clean" 2>/dev/null; then
                                echo -e "${GREEN}✓ 目录删除成功: $file_clean${NC}"
                                deleted=$((deleted + 1))
                            else
                                if find "$file_clean" -delete 2>/dev/null; then
                                    rmdir "$file_clean" 2>/dev/null && echo -e "${GREEN}✓ 目录删除成功${NC}" && deleted=$((deleted + 1))
                                else
                                    echo -e "${RED}✗ 目录删除失败: $file_clean${NC}"
                                    error_count=$((error_count + 1))
                                fi
                            fi
                        else
                            if rm -f "$file_clean" 2>/dev/null; then
                                echo -e "${GREEN}✓ 文件删除成功: $file_clean${NC}"
                                deleted=$((deleted + 1))
                            else
                                echo -e "${RED}✗ 文件删除失败: $file_clean${NC}"
                                error_count=$((error_count + 1))
                            fi
                        fi
                    else
                        echo -e "${YELLOW}⚠ 文件不存在: $file_clean${NC}"
                    fi
                done < "$LIST_FILE"
                
                echo
                echo -e "${PURPLE}=== 删除完成 ===${NC}"
                echo -e "${GREEN}成功: $deleted 个文件${NC}"
                echo -e "${RED}失败: $error_count 个文件${NC}"
                echo -e "${BLUE}总计: $file_count 个文件${NC}"
            else
                echo -e "${YELLOW}取消删除${NC}"
            fi
            ;;
        3)
            echo -e "${YELLOW}开始专项清理...${NC}"
            show_progress 5
            
            # ano_tmp清理
            paths=("/data/user/0/" "/data/user/10/" "/data/user10/" "/data/user/11/")
            for path in "${paths[@]}"; do
                find "${path}" -type d -name "ano_tmp" -exec rm -rf {} \; 2>/dev/null
            done
            echo -e "${GREEN}✓ ano_tmp清理完成${NC}"
            
            # 游戏缓存清理
            data_UAM="/data/user/0/com.tencent.mf.uam"
            sdcard_UAM="/storage/emulated/0/Android/data/com.tencent.mf.uam"
            rm -rf "$data_UAM/code_cache/*" "$sdcard_UAM/cache/*" 2>/dev/null
            echo -e "${GREEN}✓ 游戏缓存清理完成${NC}"
            
            # 系统清理
            dmesg -c >/dev/null 2>&1
            logcat -c >/dev/null 2>&1
            echo -e "${GREEN}✓ 系统日志清理完成${NC}"
            
            echo -e "${GREEN}🎯 专项清理完成！${NC}"
            ;;
        4)
            echo -e "${RED}开始网络屏蔽设置...${NC}"
            show_progress 5
            
            # 清除现有规则
            iptables -F 2>/dev/null
            iptables -X 2>/dev/null
            iptables -Z 2>/dev/null
            
            # 关键屏蔽规则
            iptables -A OUTPUT -p tcp -d api.xunyou.mobi --dport 443 -j DROP 2>/dev/null
            iptables -A OUTPUT -p tcp -d szmg.qq.com --dport 443 -j DROP 2>/dev/null
            iptables -A OUTPUT -p tcp -d snowflake.qq.com -j DROP 2>/dev/null
            iptables -A OUTPUT -p tcp -d cgi.connect.qq.com -j DROP 2>/dev/null
            
            echo -e "${GREEN}🚫 网络屏蔽已启用！${NC}"
            echo -e "${YELLOW}⚠ 注意：重启后规则会失效${NC}"
            ;;
        5)
            echo -e "${GREEN}感谢使用！文件列表保存在: $LIST_FILE${NC}"
            echo -e "${PURPLE}再见！👋${NC}"
            exit 0
            ;;
        *)
            echo -e "${RED}无效选择，请重新输入${NC}"
            ;;
    esac
done
